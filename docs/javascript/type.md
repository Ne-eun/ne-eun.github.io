---
layout: default
title: 자료형
parent: Javascript
nav_order: 1
---

# 자료형
{: .no_toc}
javascript의 변수는 어떤 특정 타입과 연결되지 않으며, 모든 타입의 값으로 할당과 재할당이 가능하다.   
기본형은 값을 그대로 할당한다.

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>

## primitive type (원시 자료형)
	javascript에서의 원시 값은 객체가 아니면서 메서드도 가지지 않는 테이터로 불변하여 변형할 수 없다.  
	변수는 새로운 값을 다시 할당할 수 있지만, 이미 생성한 원시 값은 변형할 수 없다.  
	원시 자료형은 언어와 그 구현에 따라서 메모리 상에 일대일로 대응되는 Object를 가질 수도 있다.
	언어 구조체 중 가장 빨리 연산처리 된다.

### 1. String
	텍스트 데이터를 나타낸다. 문자열 시퀀스 이다. (첫 번째 문자는 인덱스 0에 그 다음 문자는 1 ...)  
	16비트 부호 없는 정수 값 "요소"로 구성된 집합으로, 각각의 요소가 String의 한 자리를 차지한다.  
	String객체는 string primitive를 둘러싼 wrpper이다.
	C에서의 문자열은 조합형이지만, 자바스크립트에서는 기본형으로 취급한다.
	문자열을 생성한 후 바꾸는 것은 불가능 하지만 원본을 사용해 새로운 문자열을 생성하는 건 가능하다. (etc: concat, substr)
	어떠한 자료구조라도 문자열로 표현이 가능하지만 규칙이 필요하고 불필요한 유지보수의 부담이 생긴다.


### 2. Number
	부동소수점 숫자 외에도 +Infinity, -Infinity, NaN(not a number) 세 개의 상징적인 값을 가진다.  
	±Infinity 범위 내에서 가능한 가장 크거나 작은 수를 확인하려면 Number.MAX_VALUE와 Number.MIN_VALUE로 확인 가능하다.  
	Number 타입의 값 중 두 가지 방식으로 표현할 수 있는 유일한 값으로 0이 있다.  
	숫자는 보통 그 값으로만 표현되긴 하지만, javascript는 이진(비트) 연산자도 제공한다.
	-9007199254740992(-253)에서 9007199254740992(253) 사이에 있는 모든 수   
	긴 숫자를 처리할 때는 "숫자 분리기"를 사용하면 편리하다.   

```ts
const num: number = 1_000_000
```

{: .note }
> 이진 비트 연산자는 피연산자를 32비트 집합(0과 1)으로 다루고 표준 javascript 숫자값을 반환한다   
> &(비트 and), |(비트 or), ^(비트 xor)

---

### 3. Boolean: 논리 요소(true, false)
	불리은 논리적인 데이터 유형으로 참(true) 혹은 거짓(false)값만을 가질 수 있다.  
	자바스크립트에서 불린 조건은 if문, for문안에서 논리를 결정하는 데 쓰인다.

### 4. Null
	존재하지 않거나 유효하지 않은 object또는 주소를 의도적으로 가리키는 참조를 나타낸다.  
	null은 동작이 원시적으로 보이기 때문에 primitive values(원시 자료형) 중 하나로 표시된다.

### 5. Undefined
	값을 할당하지 않은 변수 혹은 값이 주어지지 않은 인수에 자동으로 할당된다.
	값이 유효하지 않은 null과 혼동될 수 있으니 주의

### 6. BigInt
	임의의 정밀도로 정수를 나타낼 수 있는 javascript 숫자 원시 값  
	Number의 안전 한계를 넘어서는 큰 정수도 안전하게 저장하고 연산할 수 있다.  
	정수 끝에 n을 추가하거나 생성자를 호출해 생성할 수 있다.  
	BigInt는 Number와 혼합해 연산할 수 없으며, 이때 TypeError가 발생한다.

### 7. Symbol
	고유하고 변경 불가능한 원시 값이며 Object의 속성 키로 사용할 수 있다.  
	어떤 프로그래밍 언어에선 "아톰"이라고 부르기도 한다.  
	내장 함수인 "Symbol()"는 함수로써 호출되면 심볼 값을 반환하나,  
	"new Symbol()"와 같은 문법으로 생성자로 사용하려 하면 에러를 발생시키는 불완전한 클래스(incomplete class)

```ts
const a = Symbol('a')
const b = a + 'b' //에러: symbol 타입에 연산이 불가능
```

{: .new}
> ES6에서 추가 되었음

---


## Reference type (참조형 데이터)

[코어 자바스크립트 - 데이터타입 (기본형과 참조형)](https://www.youtube.com/watch?v=NvuQ92iltHg)   
참조데이터 유형은 원시형과는 달리 유동적이고 대부분은 객체로 간주되므로 메서드가 있다.  
원시형 데이터의 집합이라고 생각해보자  

- Object
- Functions
- Collections
- Arrays
- Dates
- RegExp  
  ...

{: .note }
> 선언: 공간을 확보하고 해당 공간의 주소를 변수명과 매칭   
> 할당: 해당 변수가 가리키는 주소의 공간에 데이터를 저장   
> 참조: 할당된 값을 읽어 들이는 것   

---

### Object
컴퓨터 과학에서의 object는 식별자로 참조할 수 있는 메모리 상의 값을 말한다.  
javascript에서의 object는 속성의 컬렉션으로 볼 수 있다.  
객체 리터럴 구문을 사용해 제한적으로 속성을 초기화하거나 수정할 수 있다.  
속성은 'key'값으로 식별해야하며, 키값으로는 문자열이나 심볼을 사용할 수 있다.   
접근자 속성(메서드 아님!)은 키를 두개의 접근자 함수(get, set)으로 연결하여 가져오거나 저장한다.   
함수 값을 사용해서 클래스처럼 접근자를 부여할 수 있지만(closer) 그렇다고 그 객체가 클래스가 되는것은 아니다.   

---


### 자바스크립트의 메모리 구조
Stack memory: 변수, 기본형 데이터, 정적 할당   
Heap momory: 참조형 데이터, 동적 할당

---

### 원시 데이터와의 차이점

참조형 데이터는 메모리에서 해당 데이터의 위치를 가리키는 포인터를 할당한다.  
객체 자체는 Heap에 저장되고 포인터는 Stack에 저장된다.  
변수 의 값을 복사하는 것은 포인터를 복사하는 것이므로 하나의 값이 변하면 같은 포인터를 복사한 곳의 값도 변한다.

---

참조 카운트가 0인 메모리 (어떠한 데이터도 해당 메모리의 값을 참조하지 않음)의 데이터는 Garbage Collection의 수집 대상이 되어 제거 된다.
